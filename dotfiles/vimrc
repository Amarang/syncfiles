"Formatting
syntax on
" fixes error syntax for $( ) in .sh files
let g:is_posix = 1
set background=light

set backupdir=~/.backup,.
set directory=~/.backup,.

set t_Co=256
color wombat256mod

set nu
" set nowrap
set sidescroll=1


" fix backspace in tmux->ssh->vim
if &term == "screen"
    set t_kb=
endif

if exists('$TMUX')
    set term=screen-256color
endif
if exists('$UCSD')
    set term=screen-256color
endif

inoremap kj <Esc>
inoremap kJ <Esc>
inoremap KJ <Esc>
" Type kj to get out of insert or visual mode!
" virtual lag caused by the below mapping in visual mode!
" vnoremap kj <Esc>
"
if exists('$CMSSW_BASE')
    " search CMS3 first, then local CMSSW, then central CMSSW
    set path+=$CMSSW_BASE/src/CMS3/NtupleMaker/src
    set path+=$CMSSW_BASE/src
    set path+=$CMSSW_RELEASE_BASE/src
    " remove includes from autocomplete search list, otherwise slow
    set complete-=i 
endif


" control jikl (akin to wasd) will switch panes
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-l> <C-w>l
nnoremap <C-k> <C-w>k


vnoremap . :norm .<cr>

"
"
" leader stuff {{{
let mapleader = ","
map <Leader>vi :tabe ~/.vimrc<CR>
" map <leader>tn :tabnew<cr>
" map <leader>to :tabonly<cr>
" map <leader>tk :tabclose<cr>
" map <leader>tm :tabnext<cr>
map <leader>ww :set nowrap!<cr>
map <leader>nn :set nu!<cr>
map <leader>qq :wq<cr>
map <leader>ff :vertical wincmd f<CR>
map <leader>nc :NeoComplCacheEnable<CR>

" table delimited by space for whole document
map <leader>ts ggVG:Tab / <cr>:set nohl<cr>
" table delimited by comma for whole document
map <leader>tc ggVG:Tab /,<cr>
" replace multiple spaces with single space
map <leader>ss :%s/  \+/ /g<cr>

" indent file
map <Leader>i mkHmlgg=G`lzt`k

" ==========================================
" sets off header with =, /, or #, like this
" ==========================================
nnoremap <leader>h= yyPVr=jyypVr=
nnoremap <leader>h/ yyPVr/jyypVr/
nnoremap <leader>h# :center 40<cr>hhv0r#A<space><esc>20A#<esc>d40<bar>YppVr#kk.

"format paragraph to 80 chars
nnoremap <leader>pf gqap

" leader " to quote word under cursor
nnoremap <leader>" viw<esc>a"<esc>gvo<esc>i"<esc>gvo<esc>3l

" Switch between the last two files
" nnoremap <leader><leader> <c-^>

" paste from system clipboard, but only locally
nnoremap <leader>pp "+p



"note: if we wanted to do this by default, we could do
"set clipboard=unnamed
"but I'd like to have 2 main clipboards in use just in case

" set rtp+=~/powerline/powerline/bindings/vim

" (C, cpp printout) turns
" 1 2 3 
" into
" std::cout << " 1 " << 1 << " 2 " << 2 << " 3 " << 3 << std::endl;
" nnoremap <leader>cp :s/\([^ ]\+\)/<< " \1: " << \1/g<cr> :le 1<cr> :s/^ \+/std::cout /g<cr> :s/$/ << std::endl;/g<cr> :noh<cr> ==
nnoremap <leader>cp :call g:CoutTokens()<CR>

" nnoremap <leader>cc :call g:ToggleColorColumn()<CR>
" calculate quantity in Word
nnoremap <leader>cc ciW<C-r>=<C-r>"<CR><Esc>
nnoremap <leader><space> :noh<cr>

" maintain line joining even though J remapped below
nnoremap <leader>j J
vnoremap <leader>j J

nnoremap <leader><Space> :noh<CR>
" nnoremap <leader>rr :w <bar> exec '!root -l -b -q run.C'<CR>
nnoremap <leader>rr :w <bar> exec '!. all.sh'<CR>

" nnoremap <leader>xs :w <bar> exec '!xpdf -remote pdfname -exec reload &'<CR>
nnoremap <leader>xu :w <bar> exec '!xpdf -remote pdfname -z 200 output.pdf &'<CR>

" F12 toggles formatting so you can paste without
" screwing up formatting of contents.
nnoremap <leader>pt :set paste!<CR>
set pastetoggle=<F12>


nnoremap <leader>n :NeoCompleteToggle<CR>

nnoremap <leader>fv <C-w>f<C-w>L

" }}}

" o and O will put newlines below and above cursor
" nnoremap o m`o<esc>``
" nnoremap O m`O<esc>``

" stop dumb window from opening from typo
" map q: :q

nnoremap <space> %

set shortmess=atI
set backspace=indent,eol,start
set hidden

" copies a line and comments the old line
nmap zz yygccp
vmap zz V<Esc>gvygvgc`>p

" inoremap { {}<Left>
inoremap {<Tab> {<CR>}<Esc>==O
inoremap {{ {
" inoremap {} {}

" my preferred date format as an abbreviation
iab xdate <c-r>=strftime("%I:%M%p\ \%a\ %b\ %d,\ %Y")<cr>

" get rid of stupid Thanks for flying Vim title
set title 
set titleold="" 
set titlestring=VIM:\ %F 

" backspace compatibility
set bs=2

"turn on wild menu for tab command completion
set wildmenu
set wildmode=list:longest,full
set wildignorecase

" turn ruler on to show position
set ruler

" Open new split panes to right and bottom, which feels more natural
set splitbelow
set splitright

set nocp
execute pathogen#infect()


" let &t_ti.="\e[1 q"
" let &t_SI.="\e[5 q"
" let &t_EI.="\e[1 q"
" let &t_te.="\e[0 q"

let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_SR = "\<Esc>]50;CursorShape=2\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

" set runtimepath^=~/.vim/bundle/ctrlp.vim
" let g:ctrlp_map = '<c-p>'
" let g:ctrlp_cmd = 'CtrlP'

" https://coderwall.com/p/if9mda/automatically-set-paste-mode-in-vim-when-pasting-in-insert-mode
let &t_SI .= "\<Esc>[?2004h"
let &t_EI .= "\<Esc>[?2004l"
inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()
function! XTermPasteBegin()
    set pastetoggle=<Esc>[201~
    set paste
    return ""
endfunction

" easymotion
nmap s <Plug>(easymotion-overwin-f2)


" NERDTree {
    map <C-n> :NERDTreeToggle<CR>
    let g:NERDTreeDirArrows=0
" }
" TagBar {
    nmap <C-t> :TagbarToggle<CR>
" }
" vim-commentary {
    autocmd FileType cpp set commentstring=\/\/\ %s
    autocmd FileType c set commentstring=\/\/\ %s
" }

" abbreviations for misspellings
abbr hte the
abbr teh the

set scrolloff=3 " keep at least 3 lines visible on either side of cursor

set noerrorbells visualbell t_vb=
set ttyfast


" Don't redraw while executing macros (good performance config)
set lazyredraw

set cursorline          " highlight current line
set incsearch           " search as characters are entered
filetype indent on      " load FileType-specific indent files

" ENABLE USE OF MOUSE (SCROLL, SELECT, CURSOR PLACEMENT)
" in visual mode only (=a for all)
" set mouse=v

" shift hjkl over to jkl; and switch up and down
"  noremap l <down>
"  noremap k <up>
"  noremap ; <right>
"  noremap j <left>
"  
noremap K 5<up>
noremap J 5<down>

" remap arrow keys for long lines
noremap <Down> gj
noremap <Up> gk

" " MRU command-line completion
" function! s:MRUComplete(ArgLead, CmdLine, CursorPos)
"     return filter(copy(v:oldfiles), 'v:val =~ a:ArgLead')
" endfunction

" " MRU function
" function! s:MRU(command, arg)
"     if a:command == "tabedit"
"         execute a:command . " " . a:arg . "|lcd %:p:h"
"     else
"         execute a:command . " " . a:arg
"     endif
" endfunction

" " commands
" command! -nargs=1 -complete=customlist,<sid>MRUComplete ME call <sid>MRU('edit', <f-args>)
" command! -nargs=1 -complete=customlist,<sid>MRUComplete MS call <sid>MRU('split', <f-args>)
" command! -nargs=1 -complete=customlist,<sid>MRUComplete MV call <sid>MRU('vsplit', <f-args>)
" command! -nargs=1 -complete=customlist,<sid>MRUComplete MT call <sid>MRU('tabedit', <f-args>)


" cnoremap <expr> <Tab>   getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>/<C-r>/" : "<C-z>"
" cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>?<C-r>/" : "<S-Tab>"


" yank to end of line
nnoremap Y y$

" select last pasted text
nnoremap gp `[v`]


nnoremap o o<Esc><up>
nnoremap O O<Esc><down>


"remap VIM 0 to first non-blank character
map 0 ^

" statusline {{{
" show the status line always
set laststatus=2


" spell
map <F5> :setlocal spell! spelllang=en_us<CR>

" nnoremap <Enter> o<Esc>

"Sets F2 to enable and disable line numeration
nnoremap <F2> :set nonumber!<CR>:set foldcolumn=0<CR>
nnoremap <F3> :set tabstop=2<CR>:set shiftwidth=2<CR>:set softtabstop=2<CR>
nnoremap <F4> :set tabstop=4<CR>:set shiftwidth=4<CR>:set softtabstop=4<CR>

" https://bluz71.github.io/2017/05/15/vim-tips-tricks.html
" dot works over visual line selection
xnoremap . :norm.<CR>

" autocommands {{{
"
" this is why I made a group for autocommands:
" http://stackoverflow.com/questions/15353988/progressively-slower-reloading-time-of-vimrc

" for https://github.com/nathanaelkane/vim-indent-guides
" note: <leader>ig toggles the indent guides
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  ctermbg=238
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=244
let g:indent_guides_guide_size=1

" abbreviations (because snippets are stupid) {{{
" python
abbr ifnm if __name__ == "__main__" 
abbr allimps import os<CR>import sys<CR>import math<CR>
" cpp
abbr coutline std::cout << __LINE__ << std::endl;

" }}}


" " git clone https://github.com/unblevable/quick-scope ~/.vim/bundle/quick-scope
" " https://github.com/unblevable/quick-scope
" " let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
" let g:qs_highlight_on_keys = []
" let g:qs_first_occurrence_highlight_color = 155       " terminal vim
" let g:qs_second_occurrence_highlight_color = 81         " terminal vim

" " https://github.com/itchyny/vim-cursorword


if has("autocmd")

    " augroup vimrc
    "         autocmd QuickFixCmdPost * botright copen 8
    " augroup END

    augroup Group1
        autocmd!
        filetype plugin indent on
        autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif " close vim if only nerdtree is left
        au InsertLeave * set nopaste

        au FileType crontab set nobackup nowritebackup

        au BufNewFile,BufRead *.{p,gp} setlocal ft=gnuplot
        au BufNewFile,BufRead *.md setlocal ft=markdown

        au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

        " F6 executes gnuplot, python, C, C++ code by compiling and running
        " au BufEnter,BufNew *.{gp,p} map <buffer> <F6> <ESC> :w <kEnter> :!gnuplot % <kEnter>
        au FileType crontab set nobackup nowritebackup

        autocmd FileType python nnoremap <F6> :w <bar> exec '!python '.shellescape('%')<CR>
        autocmd FileType python nnoremap <leader><leader> :w <bar> exec '!python '.shellescape('%')<CR>
        " autocmd FileType python nnoremap <leader><leader> :w <bar> exec '!/usr/bin/python '.shellescape('%')<CR>
        " autocmd FileType python nnoremap <leader><leader> :w <bar> :copen <bar> :AsyncRun!  python % <bar> <C-w><C-p><CR>
        " autocmd FileType python nnoremap <leader><leader> :w <bar> :copen <bar> :AsyncRun! python %:p:h <CR>
        " autocmd FileType python nnoremap <leader><leader> :w <CR> :AsyncRun python %<CR> :copen <CR><C-w><C-p>
        autocmd FileType python nnoremap <F7> :w <bar> exec '!/cygdrive/c/Python27/python.exe '.shellescape('%')<CR>
        autocmd FileType gnuplot nnoremap <F6> :w <bar> exec '!gnuplot '.shellescape('%')<CR>
        autocmd FileType tex nnoremap <F6> :w <bar> exec '!pdflatex -quiet '.shellescape('%').'; cp '.shellescape('%:r').'.pdf ~/public_html/dump/'<CR>
        " autocmd FileType tex nnoremap <F6> :w <bar> exec '!pdflatex -quiet '.shellescape('%').'; xpdf -remote pdfname -exec reload'<CR>
        autocmd FileType tex nnoremap <F7> :w <bar> exec '!xpdf -remote pdfname -z 200 '.shellescape('%:r').'.pdf &'<CR>
        autocmd FileType c nnoremap <F6> :w <bar> exec '!gcc '.shellescape('%').' -o '.shellescape('%:r').'.exe && ./'.shellescape('%:r') . '.exe'<CR>
        " autocmd FileType cpp nnoremap <F6> :w <bar> exec '!g++ '.shellescape('%').' -o '.shellescape('%:r').'.exe && ./'.shellescape('%:r') . '.exe'<CR>
        autocmd FileType cpp nnoremap <leader><leader> :w <bar> exec '!root -b -q -l -n '.shellescape('%')<CR>
        autocmd FileType sh nnoremap <F6> :w <bar> exec '!. '.shellescape('%')<CR>
        autocmd FileType sh nnoremap <leader><leader> :w <bar> exec '!./'.shellescape('%')<CR>
        " put printf template into code if using c++ and type PF in insert mode
        " autocmd FileType cpp inoremap PF printf("\n",);<Esc>=0f\i
        autocmd FileType markdown nnoremap <F6> :w <bar> exec "!'/cygdrive/c/Program Files (x86)/Google/Chrome/Application/chrome.exe' ".shellescape('%')<CR>
        autocmd FileType html nnoremap <F6> :w <bar> exec "!'/cygdrive/c/Program Files (x86)/Google/Chrome/Application/chrome.exe' ".shellescape('%')<CR>
        " autocmd FileType vim nnoremap <leader><leader> :w <bar> source shellescape('%')<CR>
        autocmd FileType vim nnoremap <leader><leader> :w <bar> source %<CR>
        autocmd FileType vim nnoremap <leader>ts :call Test()<CR>

        autocmd BufWritePost .vimrc source %


        " if exists("+relativenumber")
        "     set rnu | set nu
        "     au InsertEnter * :set nornu | set number
        "     au InsertLeave * :set relativenumber
        " endif

    augroup END
endif

" }}}


function! g:ToggleColorColumn()
    if &colorcolumn != ''
        setlocal colorcolumn&
    else
        setlocal colorcolumn=80
    endif
endfunction

fu! CoutTokens()
    " toggles between
    "    std::cout << " blah1: " << blah1 << " blah2: " << blah2 << " blah3: " << blah3 << std::endl;
    " and
    "    blah1 blah2 blah3  
    "
    let line=getline('.')

    " turn into cout statement or reverse, depending on if 
    " line contains std::cout"
    let newstr = ""
    if line =~ "std::cout"
        let words = split(line," << ")
        for word in words
            " if token has these things then it's not a variable by itself
            if word =~ "std::" || word =~ ": "
                continue
            endif
            let newstr .= word . " "
        endfor
    else
        let words = split(line)
        let newstr .= "std::cout << "
        for word in words
            " if there's a quote in the variable, replace it with single tick
            let escword = substitute(word, "\"", "'", "g")
            let newstr .= " \" " . escword . ": \" << " . word . " << "
        endfor
        let newstr .= " std::endl;"
    endif

    :d
    :-1put =newstr
    execute "norm! =="
endfu




" continue comment if in insert mode
" but not when hitting o/O
set formatoptions+=cr
set formatoptions-=o


set autochdir

set tabstop=4
set shiftwidth=4
set softtabstop=4
set smarttab
set expandtab

"Set title of window to file name
set title


set showmatch
set matchtime=3
set incsearch
set hlsearch
"Ignores case for searches
set ignorecase
"case-sensitive if search contains an uppercase character
set smartcase


"Remember previous buffer session
exec 'set viminfo=%,' . &viminfo


set noswapfile

" ([])
hi MatchParen cterm=none ctermbg=none ctermfg=yellow
hi Statement cterm=bold

