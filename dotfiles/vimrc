"Formatting
syntax on
" fixes error syntax for $( ) in .sh files
let g:is_posix = 1
set background=light

set backupdir=~/.backup,.
set directory=~/.backup,.

set t_Co=256
color wombat256mod

set nu
" set nowrap


" fix backspace in tmux->ssh->vim
if &term == "screen"
    set t_kb=
endif

if exists('$TMUX')
    set term=screen-256color
endif
if exists('$UCSD')
    set term=screen-256color
endif

inoremap kj <Esc>
inoremap kJ <Esc>
" Type kj to get out of insert or visual mode!
" virtual lag caused by the below mapping in visual mode!
" vnoremap kj <Esc>

" control jikl (akin to wasd) will switch panes
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-l> <C-w>l
nnoremap <C-k> <C-w>k


" leader stuff {{{
let mapleader = ","
map <Leader>vi :tabe ~/.vimrc<CR>
map <leader>tn :tabnew<cr>
map <leader>to :tabonly<cr>
map <leader>tk :tabclose<cr>
map <leader>tm :tabnext<cr>
map <leader>ww :w!<cr>
map <leader>qq :wq<cr>

" indent file
map <Leader>i mkHmlgg=G`lzt`k

" ==========================================
" sets off header with =, /, or #, like this
" ==========================================
nnoremap <leader>h= yyPVr=jyypVr=
nnoremap <leader>h/ yyPVr/jyypVr/
nnoremap <leader>h# yyPVr#jyypVr#

"format paragraph to 80 chars
nnoremap <leader>pf gqap

" leader " to quote word under cursor
nnoremap <leader>" viw<esc>a"<esc>gvo<esc>i"<esc>gvo<esc>3l

" Switch between the last two files
" nnoremap <leader><leader> <c-^>

" paste from system clipboard, but only locally
nnoremap <leader>pp "+p



"note: if we wanted to do this by default, we could do
"set clipboard=unnamed
"but I'd like to have 2 main clipboards in use just in case

" set rtp+=~/powerline/powerline/bindings/vim

" (C, cpp printout) turns
" 1 2 3 
" into
" std::cout << " 1 " << 1 << " 2 " << 2 << " 3 " << 3 << std::endl;
nnoremap <leader>cp :s/\([^ ]\+\)/<< " \1: " << \1/g<cr> :le 1<cr> :s/^ \+/std::cout /g<cr> :s/$/ << std::endl;/g<cr> :noh<cr> ==

nnoremap <leader>cc :call g:ToggleColorColumn()<CR>
nnoremap <leader><space> :noh<cr>

" maintain line joining even though J remapped below
nnoremap <leader>j J
vnoremap <leader>j J

nnoremap <leader><Space> :noh<CR>
" nnoremap <leader>rr :w <bar> exec '!root -l -b -q run.C'<CR>
nnoremap <leader>rr :w <bar> exec '!. all.sh'<CR>

" nnoremap <leader>xs :w <bar> exec '!xpdf -remote pdfname -exec reload &'<CR>
nnoremap <leader>xu :w <bar> exec '!xpdf -remote pdfname -z 200 output.pdf &'<CR>

" F12 toggles formatting so you can paste without
" screwing up formatting of contents.
nnoremap <leader>pt :set paste!<CR>
set pastetoggle=<F12>


nnoremap <leader>n :NeoCompleteToggle<CR>

" }}}

" o and O will put newlines below and above cursor
" nnoremap o m`o<esc>``
" nnoremap O m`O<esc>``

" stop dumb window from opening from typo
" map q: :q

nnoremap <space> %

set shortmess=atI
set backspace=indent,eol,start
set hidden

" copies a line and comments the old line
nmap zz yygccp
vmap zz V<Esc>gvygvgc`>p

" inoremap { {}<Left>
inoremap {<Tab> {<CR>}<Esc>==O
inoremap {{ {
" inoremap {} {}

" my preferred date format as an abbreviation
iab xdate <c-r>=strftime("%I:%M%p\ \%a\ %b\ %d,\ %Y")<cr>

" get rid of stupid Thanks for flying Vim title
set title 
set titleold="" 
set titlestring=VIM:\ %F 

" backspace compatibility
set bs=2

"turn on wild menu for tab command completion
set wildmenu
set wildmode=list:longest,full
set wildignorecase

" turn ruler on to show position
set ruler

" Open new split panes to right and bottom, which feels more natural
set splitbelow
set splitright

set nocp
execute pathogen#infect()


let &t_ti.="\e[1 q"
let &t_SI.="\e[5 q"
let &t_EI.="\e[1 q"
let &t_te.="\e[0 q"

" set runtimepath^=~/.vim/bundle/ctrlp.vim
" let g:ctrlp_map = '<c-p>'
" let g:ctrlp_cmd = 'CtrlP'

" easymotion
nmap s <Plug>(easymotion-overwin-f2)

" NERDTree {
    map <C-n> :NERDTreeToggle<CR>
    let g:NERDTreeDirArrows=0
" }
" TagBar {
    nmap <C-t> :TagbarToggle<CR>
" }
" vim-commentary {
    autocmd FileType cpp set commentstring=\/\/\ %s
    autocmd FileType c set commentstring=\/\/\ %s
" }

" abbreviations for misspellings
abbr hte the
abbr teh the

set scrolloff=3 " keep at least 3 lines visible on either side of cursor

set noerrorbells visualbell t_vb=
set ttyfast


" Don't redraw while executing macros (good performance config)
set lazyredraw

set cursorline          " highlight current line
set incsearch           " search as characters are entered
filetype indent on      " load FileType-specific indent files

" ENABLE USE OF MOUSE (SCROLL, SELECT, CURSOR PLACEMENT)
" in visual mode only (=a for all)
" set mouse=v

" shift hjkl over to jkl; and switch up and down
"  noremap l <down>
"  noremap k <up>
"  noremap ; <right>
"  noremap j <left>
"  
noremap K 5<up>
noremap J 5<down>

" remap arrow keys for long lines
noremap <Down> gj
noremap <Up> gk

" MRU command-line completion
function! s:MRUComplete(ArgLead, CmdLine, CursorPos)
    return filter(copy(v:oldfiles), 'v:val =~ a:ArgLead')
endfunction

" MRU function
function! s:MRU(command, arg)
    if a:command == "tabedit"
        execute a:command . " " . a:arg . "|lcd %:p:h"
    else
        execute a:command . " " . a:arg
    endif
endfunction

" commands
command! -nargs=1 -complete=customlist,<sid>MRUComplete ME call <sid>MRU('edit', <f-args>)
command! -nargs=1 -complete=customlist,<sid>MRUComplete MS call <sid>MRU('split', <f-args>)
command! -nargs=1 -complete=customlist,<sid>MRUComplete MV call <sid>MRU('vsplit', <f-args>)
command! -nargs=1 -complete=customlist,<sid>MRUComplete MT call <sid>MRU('tabedit', <f-args>)


" cnoremap <expr> <Tab>   getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>/<C-r>/" : "<C-z>"
" cnoremap <expr> <S-Tab> getcmdtype() == "/" \|\| getcmdtype() == "?" ? "<CR>?<C-r>/" : "<S-Tab>"


" yank to end of line
nnoremap Y y$

" select last pasted text
nnoremap gp `[v`]


nnoremap o o<Esc><up>
nnoremap O O<Esc><down>


"remap VIM 0 to first non-blank character
map 0 ^

" statusline {{{
" show the status line always
set laststatus=2


" spell
map <F5> :setlocal spell! spelllang=en_us<CR>

" nnoremap <Enter> o<Esc>

"Sets F2 to enable and disable line numeration
nnoremap <F2> :set nonumber!<CR>:set foldcolumn=0<CR>
nnoremap <F3> :set tabstop=2<CR>:set shiftwidth=2<CR>:set softtabstop=2<CR>
nnoremap <F4> :set tabstop=4<CR>:set shiftwidth=4<CR>:set softtabstop=4<CR>

" autocommands {{{
"
" this is why I made a group for autocommands:
" http://stackoverflow.com/questions/15353988/progressively-slower-reloading-time-of-vimrc

if has("autocmd")
    augroup Group1
        autocmd!
        filetype plugin indent on
        autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif " close vim if only nerdtree is left
        au InsertLeave * set nopaste

        au BufNewFile,BufRead *.{p,gp} setlocal ft=gnuplot
        au BufNewFile,BufRead *.md setlocal ft=markdown
        " F6 executes gnuplot, python, C, C++ code by compiling and running
        " au BufEnter,BufNew *.{gp,p} map <buffer> <F6> <ESC> :w <kEnter> :!gnuplot % <kEnter>
        autocmd FileType python nnoremap <F6> :w <bar> exec '!python '.shellescape('%')<CR>
        autocmd FileType python nnoremap <leader><leader> :w <bar> exec '!python '.shellescape('%')<CR>
        autocmd FileType python nnoremap <F7> :w <bar> exec '!/cygdrive/c/Python27/python.exe '.shellescape('%')<CR>
        autocmd FileType gnuplot nnoremap <F6> :w <bar> exec '!gnuplot '.shellescape('%')<CR>
        autocmd FileType tex nnoremap <F6> :w <bar> exec '!pdflatex -quiet '.shellescape('%').'; cp '.shellescape('%:r').'.pdf ~/public_html/dump/'<CR>
        " autocmd FileType tex nnoremap <F6> :w <bar> exec '!pdflatex -quiet '.shellescape('%').'; xpdf -remote pdfname -exec reload'<CR>
        autocmd FileType tex nnoremap <F7> :w <bar> exec '!xpdf -remote pdfname -z 200 '.shellescape('%:r').'.pdf &'<CR>
        autocmd FileType c nnoremap <F6> :w <bar> exec '!gcc '.shellescape('%').' -o '.shellescape('%:r').'.exe && ./'.shellescape('%:r') . '.exe'<CR>
        " autocmd FileType cpp nnoremap <F6> :w <bar> exec '!g++ '.shellescape('%').' -o '.shellescape('%:r').'.exe && ./'.shellescape('%:r') . '.exe'<CR>
        autocmd FileType cpp nnoremap <leader><leader> :w <bar> exec '!root -b -q -l'.shellescape('%')<CR>
        autocmd FileType sh nnoremap <F6> :w <bar> exec '!. '.shellescape('%')<CR>
        " put printf template into code if using c++ and type PF in insert mode
        " autocmd FileType cpp inoremap PF printf("\n",);<Esc>=0f\i
        autocmd FileType markdown nnoremap <F6> :w <bar> exec "!'/cygdrive/c/Program Files (x86)/Google/Chrome/Application/chrome.exe' ".shellescape('%')<CR>
        autocmd FileType html nnoremap <F6> :w <bar> exec "!'/cygdrive/c/Program Files (x86)/Google/Chrome/Application/chrome.exe' ".shellescape('%')<CR>

        autocmd BufWritePost .vimrc source %


        " if exists("+relativenumber")
        "     set rnu | set nu
        "     au InsertEnter * :set nornu | set number
        "     au InsertLeave * :set relativenumber
        " endif

    augroup END
else
    set autoindent
endif

" }}}


function! g:ToggleColorColumn()
    if &colorcolumn != ''
        setlocal colorcolumn&
    else
        setlocal colorcolumn=80
    endif
endfunction


" continue comment if in insert mode
" but not when hitting o/O
set formatoptions+=cr
set formatoptions-=o


set autochdir

set tabstop=4
set shiftwidth=4
set softtabstop=4
set smarttab
set expandtab

"Set title of window to file name
set title


set showmatch
set matchtime=3
set incsearch
set hlsearch
"Ignores case for searches
set ignorecase
"case-sensitive if search contains an uppercase character
set smartcase


"Remember previous buffer session
exec 'set viminfo=%,' . &viminfo


set noswapfile

" ([])
hi MatchParen cterm=none ctermbg=none ctermfg=yellow
hi Statement cterm=bold

